<?php
namespace SpiceCRM\includes\Alcatel;

use SpiceCRM\includes\database\DBManagerFactory;
use SpiceCRM\includes\Logger\LoggerManager;
use SpiceCRM\includes\SugarObjects\SpiceConfig;
use SpiceCRM\includes\VoiceOverIP\VoiceOverIP;
use SpiceCRM\includes\VoiceOverIP\VoiceOverIPCall;

class Alcatel extends VoiceOverIP
{
    protected $preferenceName     = 'alcatel';
    protected $preferenceCategory = 'alcatel';
    protected $channelPrefix      = 'alcatel';

    public function __construct() {
        
        $this->config = SpiceConfig::getInstance()->config['alcatel'];
    }

    /**
     * Logs in to the node.js server.
     *
     * @return mixed
     */
    public function loginToNode() {
        $connector = $this->getNewConnector();
        return $connector->loginToNode();
    }

    /**
     * {@inheritdoc}
     *
     * @param $msisdn
     * @return bool|mixed
     */
    public function initiateCall($msisdn) {
        $connector = $this->getNewConnector();
        $callId = $connector->initiateCall($msisdn);

        // write teh call to the database
        if ($callId !== false) {
            $prefs = $this->getPreferences();
            $callInfo = $connector->fetchCallInfo($callId);
            $call = $this->createCall(
                $prefs['username'],
                self::DIRECTION_OUTGOING,
                $callId,
                $callInfo->callData->state,
                $callInfo->legs[0]->deviceId,
                $msisdn,
                '',
                $callId
            );
            $this->writeCall($call);
        }

        return $callId;
    }

    /**
     * Handles the incoming Alcatel OpenTouch events.
     * $event['callRef'] always contains active call id sent by alcatel
     *
     * @param $event
     * @return mixed|void
     */
    public function handleEvent($event) {
        if ($event['message'] == 'RESTART') {
            LoggerManager::getLogger()->fatal('Restarting Alcatel');
            return $this->notifySocket($this->channelPrefix, null, '/restart');
        }

        if (!$event['callRef']) {
            return;
        }

        // check if we have an entry in voipcalls table
        $thisCall = $this->getCall($event['callRef']);

        // pass $thisCall['id'] when entry was found (will contain the original call id generated by alcatel)
        // pass $event['previousCallRef'] when $thisCall was not found
        $call = $this->createCall(
            session_id(),
            $thisCall['calldirection'],
            $event['callRef'],
            $this->determineState($event),
            $thisCall['callernumber'] ?? $event['participants'][0]['participantId'] ?? $event['addedParticipants'][0]['participantId'],
            $thisCall['callednumber'] ?? $event['legs'][0]['deviceId'] ?? $event['modifiedLegs'][0]['deviceId'],
            $event['eventName'],
            $thisCall['id'] ?? $event['previousCallRef']
        );

        if ($call->direction && $call->callernumber && $call->callednumber) {
            // write to the database
            $this->writeCall($call);
            // post to the nodejs server
            $this->notifySocket($call->channel, $call);
        }
    }

    /**
     * Determines the state of a call.
     * Some events do not contain the call state.
     * The call state is translated into states used by the UI.
     *
     * @param $event
     * @return mixed|string
     */
    private function determineState($event) {
        if ($event['eventName'] == 'OnCallRemoved') {
            return 'HANGUP';
        }

        switch ($event['callData']['state']) {
            case 'RINGING_INCOMING':
                return 'INCOMING';
            case 'ACTIVE':
                return 'CONNECTED';
            case 'RINGING_OUTGOING':
                return 'RINGING';
            case 'RELEASING':
                return 'HANGUP';
            case 'DIALING':
                return 'PROCEEDING';
            default:
                return $event['callData']['state'];
        }
    }


    /**
     * {@inheritdoc}
     * @return mixed|AlcatelConnector
     */
    protected function getNewConnector() {
        return new AlcatelConnector();
    }

    /**
     * Creates a call object.
     * Alcatel might create a second call (and probably more) during dialing process
     * This second call is related to the original call using previousCallRef property.
     * The logic we use is:
     * We save in table voipcalls 1 entry with the original alcatel call id as id and the active call id as activecallid
     * The active call id is updated in this entry each time it is switched by alcatel
     * On initiate call id and active call id have the same value
     * During dialing process they have different values
     * $callRef is always the active call id sent by alcatel.
     * $previousCallRef is not always in alcatel's message. When it is there we use the value to recognize the original id
     * When it is not there we use the results id from getCall()
     *
     * @param $channel
     * @param $direction
     * @param $callRef // the active call id
     * @param $state
     * @param $callernumber
     * @param $callednumber
     * @param $event
     * @param null $previousCallRef // the original call id
     * @return VoiceOverIPCall
     */
    protected function createCall($channel, $direction, $callRef, $state, $callernumber, $callednumber, $event, $previousCallRef = null): VoiceOverIPCall {
        $call = new VoiceOverIPCall();

        $call->state        = $state;

        if (empty($direction)) {
            switch ($state) {
                case 'INCOMING':
                    $call->direction = self::DIRECTION_INCOMING;
                    $call->callernumber = $this->parsePhoneNumber($callernumber);
                    $call->callednumber = $callednumber; // is the deviceId, no proper phone number
                    break;
                case 'PROCEEDING':
                case 'RINGING':
                    $call->direction = self::DIRECTION_OUTGOING;
                    $call->callednumber = $callernumber; // is the deviceId, no proper phone number
                    $call->callernumber = $this->parsePhoneNumber($callednumber);
                    break;
            }
        } else {
            $call->direction    = $direction;
            $call->callernumber = $callernumber;
            $call->callednumber = $callednumber;
        }

        $call->channel      = $this->channelPrefix . $channel;
        $call->id           = $previousCallRef ?? $callRef;
        $call->event        = $event;
        $call->activecallid = $callRef;

        return $call;
    }

    /**
     * Returns the phone number formatted to be dialable by Alcatel.
     *
     * @param $number
     * @return false|mixed
     */
    public function dialable($number) {
        $connector = new AlcatelConnector();
        return $connector->getDialableNumber($number);
    }

    /**
     * Parses the phone number into a E164 format
     * assuming that country code and area code are included in the number
     * This might be customer specific.
     *
     * @param $number
     * @return false|string E164 phone number format like +12124356405
     */
    protected function parsePhoneNumber($number) {
        // remove the first char (coming in as 00012124356405 or +12124356405)
        $number = substr($number, 1);

        // international number
        if (substr($number,0, 2) == '00') {
            $tempNumber = substr($number, 2);
            return '+' . $tempNumber;
        }

        // austrian number
        if (substr($number, 0, 1) == '0') {
            $tempNumber = substr($number, 1);
            return '+43' . $tempNumber;
        }

        return $number;
    }

    /**
     * Returns a call with the given ID.
     * Field activecallid always contains current call id sent by alcatel
     * @see createCall() comment for further details
     *
     * @param $activecallid
     * @return mixed
     */
    protected function getCall($activecallid) {
        $db = DBManagerFactory::getInstance();
        return $db->fetchByAssoc($db->query("SELECT * FROM voipcalls WHERE activecallid='$activecallid'"));
    }

    /**
     * Saves the call information in the DB.
     * Field activecallid always contains current call id sent by alcatel
     * @see createCall() comment for further details
     *
     * @param $call
     * @throws \Exception
     */
    protected function writeCall($call) {
        $db = DBManagerFactory::getInstance();

        $record = $db->fetchByAssoc($db->query("SELECT id FROM voipcalls WHERE id='$call->id' OR activecallid='$call->activecallid'"));
        if ($record) {  // update
            $pks = ['id' => $record['id']];
            $data = ['callstate' => $call->state];
            if ($call->activecallid != $call->id) {
                $data['activecallid'] =  $call->activecallid;
            }
            $db->updateQuery('voipcalls', $pks, $data);

        } else { // insert
            $data = [
                'id' => $call->id,
                'channel' => $call->channel,
                'calldirection' => $call->direction,
                'callstate' => $call->state,
                'callednumber' => $call->callednumber,
                'callernumber' => $call->callernumber,
                'activecallid' => $call->activecallid,
            ];
            $db->insertQuery('voipcalls', $data);
        }
    }
}
